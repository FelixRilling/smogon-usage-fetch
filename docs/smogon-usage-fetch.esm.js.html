<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>smogon-usage-fetch.esm.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <h2><a href="index.html">Home</a></h2><h3>Global</h3><ul><li><a href="global.html#fetchChaos">fetchChaos</a></li><li><a href="global.html#fetchFormats">fetchFormats</a></li><li><a href="global.html#fetchLeads">fetchLeads</a></li><li><a href="global.html#fetchTimeframes">fetchTimeframes</a></li><li><a href="global.html#fetchUsage">fetchUsage</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">smogon-usage-fetch.esm.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import fetch from 'node-fetch';
import { load } from 'cheerio';
import { isRegExp, isNil, arrCompact } from 'lightdash';

/**
 * Off-brand path.join().
 *
 * @private
 * @param args URL paths to join.
 * @return Joined URL.
 */
const urlJoin = (...args) => args.join("/");
/**
 * Simple helper to throw exceptions for non-success status codes.
 *
 * @private
 * @param res Fetch Response
 * @return Fetch response.
 */
const checkStatus = (res) => {
    if (!res.ok) {
        throw new Error(`Error while fetching '${res.url}': ${res.statusText} (${res.status}).`);
    }
    return res;
};

const URL_BASE = "http://www.smogon.com";
const URL_PATH_STATS = "stats";
const URL_STATS = urlJoin(URL_BASE, URL_PATH_STATS);

/**
 * Loads a list of strings from the default apache2 directory listing.
 *
 * @private
 * @param html Html of the directory list.
 * @return List of page entries
 */
const parseList = (html) => {
    const $ = load(html);
    return $("pre a")
        .filter((i, el) => $(el).text() !== "../") // Filter Link to previous directory
        .map((i, el) => $(el).text()) // Only use link text
        .get();
};

/**
 * Removes trailing sequences from a string.
 *
 * @private
 * @param str String to use.
 * @param seq Sequence to remove.
 * @return String without trailing sequence.
 */
const removeTrailing = (str, seq) => {
    if (isRegExp(seq)) {
        return str.replace(seq, "");
    }
    return str.includes(seq) ? str.substr(0, str.lastIndexOf(seq)) : str;
};
/**
 * Removes trailing slashes from a string.
 *
 * @private
 * @param str String to use.
 * @return String without trailing slash.
 */
const removeTrailingSlash = (str) => removeTrailing(str, "/");
/**
 * Removes file extension from a string
 *
 * @private
 * @param str String to use.
 * @return String without file extension.
 */
const removeExtension = (str) => removeTrailing(str, /\..+$/);
/**
 * Checks if a file name is a directory.
 *
 * @private
 * @param str String to check.
 * @return If the file is a directory.
 */
const isFile = (str) => !str.endsWith("/");

/**
 * Loads a list of all available timeframes.
 *
 * @public
 * @return List of timeframe names.
 */
const fetchTimeframes = async () => fetch(urlJoin(URL_STATS))
    .then(checkStatus)
    .then(res => res.text())
    .then(html => parseList(html).map(removeTrailingSlash));

/**
 * Loads a list of all available formats for a given timeframe.
 *
 * @public
 * @return List of format names.
 */
const fetchFormats = async (timeframe) => fetch(urlJoin(URL_STATS, timeframe))
    .then(checkStatus)
    .then(res => res.text())
    .then(html => parseList(html)
    .filter(isFile)
    .map(removeExtension));

const URL_PATH_CHAOS = "chaos";
/**
 * Loads the chaos data for a given timeframe and format.
 *
 * @public
 * @return Object containing chaos data.
 */
const fetchChaos = async (timeframe, format) => fetch(urlJoin(URL_STATS, timeframe, URL_PATH_CHAOS, `${format}.json`))
    .then(checkStatus)
    .then(res => res.json());

/**
 * Gets a group match as a number.
 *
 * @private
 * @param str String to use.
 * @param regex Regex to match.
 * @param groupIndex Index to get.
 * @return The non-NaN group result number.
 * @throws when the group is not found or cannot be converted.
 */
const getGroupMatchAsNumber = (str, regex, groupIndex) => {
    const errNotFound = new Error(`Could not find match for '${regex}' in '${str}'.`);
    if (!regex.test(str)) {
        throw errNotFound;
    }
    const match = str.match(regex);
    if (isNil(match) || isNil(match[groupIndex])) {
        throw errNotFound;
    }
    const num = Number(match[groupIndex]);
    if (Number.isNaN(num)) {
        throw errNotFound;
    }
    return num;
};

/**
 * Parses a single markdown table row and returns the values.
 *
 * @private
 * @param row Markdown table row.
 * @return Values of the row.
 */
const parseTableRow = (row) => arrCompact(row.split("|").map(str => str.trim()));
// noinspection SpellCheckingInspection
/**
 * A simple markdown table parser. Designed for a markdown table with a header,
 * containing any amount of rows and columns.
 *
 * @private
 * @param table Markdown table.
 * @return Object containing the table data.
 * @example
 * const table = `+ ---- + ------------------ + --------- + ------ + ------- + ------ + ------- +
 *                | Rank | Pokemon            | Usage %   | Raw    | %       | Real   | %       |
 *                + ---- + ------------------ + --------- + ------ + ------- + ------ + ------- +
 *                | 1    | Skarmory           | 19.96100% | 2252   | 19.961% | 1743   | 21.008% |
 *                | 2    | Gengar             | 19.01259% | 2145   | 19.013% | 1541   | 18.574% |
 *                | 3    | Suicune            | 14.02234% | 1582   | 14.022% | 1165   | 14.042% |
 *                | 4    | Victini            | 13.91597% | 1570   | 13.916% | 1172   | 14.126% |
 *                | 5    | Lucario            | 13.42847% | 1515   | 13.428% | 1073   | 12.933% |
 *                + ---- + ------------------ + --------- + ------ + ------- + ------ + ------- +`;
 *
 * const tableJSON = parseTable(str);
 *
 * tableJSON === {
 *     header: ["Rank", "Pokemon", "Usage %", "Raw", "%", "Real", "%"],
 *     rows: [
 *         ["1", "Skarmory", "19.96100%", "2252", "19.961%", "1743", "21.008%"],
 *         ["2", "Gengar",   "19.01259%", "2145", "19.013%", "1541", "18.574%"],
 *         ["3", "Suicune",  "14.02234%", "1582", "14.022%", "1165", "14.042%"],
 *         ["4", "Victini",  "13.91597%", "1570", "13.916%", "1172", "14.126%"],
 *         ["5", "Lucario",  "13.42847%", "1515", "13.428%", "1073", "12.933%"]
 *     ]
 * }
 */
const parseTable = (table) => {
    const rows = table.split("\n");
    const headerRow = rows[1];
    const dataRows = rows.slice(3, rows.length - 2);
    return {
        header: parseTableRow(headerRow),
        rows: dataRows.map(parseTableRow)
    };
};

const PERCENTAGE_UNIT = "%";
/**
 * Parses a smogon markdown table.
 *
 * @private
 * @param table Table to parse.
 * @param currentTableLayout Layout to parse by.
 * @return Parsed table.
 */
const parseSmogonTable = (table, currentTableLayout) => {
    const tableData = parseTable(table);
    const columnLength = tableData.header.length;
    if (columnLength !== currentTableLayout.length) {
        throw new Error(`Table does not have the right amount of columns: '${columnLength}' instead of '${currentTableLayout.length}'.`);
    }
    return {
        header: currentTableLayout.map(layoutRow => layoutRow.name),
        rows: tableData.rows.map(row => row.map((field, i) => currentTableLayout[i].converter(field)))
    };
};

const USAGE_TOTAL_REGEX = /Total battles: (\d+)/;
const USAGE_WEIGHT_REGEX = /Avg\. weight\/team: ([\d.]+)/;
const USAGE_TABLE_LAYOUT = [
    { name: "Rank" /* RANK */, converter: str => Number(str) },
    { name: "Pokemon" /* POKEMON */, converter: str => str },
    {
        name: "Usage Percentage" /* USAGE_PERCENTAGE */,
        converter: str => Number(removeTrailing(str, PERCENTAGE_UNIT))
    },
    { name: "Usage Raw" /* USAGE_RAW */, converter: str => Number(str) },
    {
        name: "Usage Raw Percentage" /* USAGE_RAW_PERCENTAGE */,
        converter: str => Number(removeTrailing(str, PERCENTAGE_UNIT))
    },
    { name: "Usage Real" /* USAGE_REAL */, converter: str => Number(str) },
    {
        name: "Usage Real Percentage" /* USAGE_REAL_PERCENTAGE */,
        converter: str => Number(removeTrailing(str, PERCENTAGE_UNIT))
    }
];
/**
 * Parses a smogon usage page.
 *
 * @private
 * @param page Page to parse.
 * @return parsed page.
 */
const parseUsagePage = (page) => {
    const rows = page.split("\n");
    const totalRow = rows[0];
    const weightRow = rows[1];
    const tableRows = rows.slice(2);
    return {
        total: getGroupMatchAsNumber(totalRow, USAGE_TOTAL_REGEX, 1),
        weight: getGroupMatchAsNumber(weightRow, USAGE_WEIGHT_REGEX, 1),
        data: parseSmogonTable(tableRows.join("\n"), USAGE_TABLE_LAYOUT)
    };
};

/**
 * Loads usage data for the given timeframe and format.
 *
 * @public
 * @return Usage data.
 */
const fetchUsage = async (timeframe, format) => fetch(urlJoin(URL_STATS, timeframe, `${format}.txt`))
    .then(checkStatus)
    .then(res => res.text())
    .then(parseUsagePage);

const LEADS_TOTAL_REGEX = /Total leads: (\d+)/;
const LEADS_TABLE_LAYOUT = [
    { name: "Rank" /* RANK */, converter: str => Number(str) },
    { name: "Pokemon" /* POKEMON */, converter: str => str },
    {
        name: "Usage Percentage" /* USAGE_PERCENTAGE */,
        converter: str => Number(removeTrailing(str, PERCENTAGE_UNIT))
    },
    { name: "Usage Raw" /* USAGE_RAW */, converter: str => Number(str) },
    {
        name: "Usage Raw Percentage" /* USAGE_RAW_PERCENTAGE */,
        converter: str => Number(removeTrailing(str, PERCENTAGE_UNIT))
    }
];
/**
 * Parses a smogon leads page.
 *
 * @private
 * @param page Page to parse.
 * @return parsed page.
 */
const parseLeadsPage = (page) => {
    const rows = page.split("\n");
    const totalRow = rows[0];
    const tableRows = rows.slice(1);
    return {
        total: getGroupMatchAsNumber(totalRow, LEADS_TOTAL_REGEX, 1),
        data: parseSmogonTable(tableRows.join("\n"), LEADS_TABLE_LAYOUT)
    };
};

const URL_PATH_LEADS = "leads";
/**
 * Loads leads data for the given timeframe and format.
 *
 * @public
 * @return Leads data.
 */
const fetchLeads = async (timeframe, format) => fetch(urlJoin(URL_STATS, timeframe, URL_PATH_LEADS, `${format}.txt`))
    .then(checkStatus)
    .then(res => res.text())
    .then(parseLeadsPage);

export { fetchTimeframes, fetchFormats, fetchUsage, fetchChaos, fetchLeads };
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Jan 06 2019 11:47:44 GMT+0100 (Central European Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>


</body>
</html>
